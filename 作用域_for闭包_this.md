深入理解javascript作用域系列的第一篇——内部原理

　　内部原理分成编译、执行、查询、嵌套和异常五个部分进行介绍，最后以一个实例过程对原理进行完整说明

# 编译
　　以var a = 2;为例，说明javascript的内部编译过程，主要包括以下三步：

【1】分词(tokenizing)

　　把由字符组成的字符串分解成有意义的代码块，这些代码块被称为词法单元(token)

　　var a = 2;被分解成为下面这些词法单元：var、a、=、2、;。这些词法单元组成了一个词法单元流数组

// 词法分析后的结果
[
  "var" : "keyword",
  "a" : "identifier",
  "="   : "assignment",
  "2"  : "integer",
  ";"   : "eos" (end of statement)
]
【2】解析(parsing)

　　把词法单元流数组转换成一个由元素逐级嵌套所组成的代表程序语法结构的树，这个树被称为“抽象语法树” (Abstract Syntax Tree, AST)

　　var a = 2;的抽象语法树中有一个叫VariableDeclaration的顶级节点，接下来是一个叫Identifier(它的值是a)的子节点，以及一个叫AssignmentExpression的子节点，且该节点有一个叫Numericliteral(它的值是2)的子节点

{
  operation: "=",
  left: {
    keyword: "var",
    right: "a"
  }
  right: "2"
}
【3】代码生成

　　将AST转换为可执行代码的过程被称为代码生成

　　var a=2;的抽象语法树转为一组机器指令，用来创建一个叫作a的变量(包括分配内存等)，并将值2储存在a中

　　实际上，javascript引擎的编译过程要复杂得多，包括大量优化操作，上面的三个步骤是编译过程的基本概述

　　任何代码片段在执行前都要进行编译，大部分情况下编译发生在代码执行前的几微秒。javascript编译器首先会对var a=2;这段程序进行编译，然后做好执行它的准备，并且通常马上就会执行它

 

# 执行
　　简而言之，编译过程就是编译器把程序分解成词法单元(token)，然后把词法单元解析成语法树(AST)，再把语法树变成机器指令等待执行的过程

　　实际上，代码进行编译，还要执行。下面仍然以var a = 2;为例，深入说明编译和执行过程

【1】编译
    对于  var a = 2;
　　1、编译器查找作用域是否已经有一个名称为a的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为a

　　2、编译器将var a = 2;这个代码片段编译成用于执行的机器指令

　　[注意]依据编译器的编译原理，javascript中的重复声明是合法的

//test在作用域中首次出现，所以声明新变量，并将20赋值给test
var test = 20;
//test在作用域中已经存在，直接使用，将20的赋值替换成30
var test = 30;
【2】执行

　　1、引擎运行时会首先查询作用域，在当前的作用域集合中是否存在一个叫作a的变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量

　　2、如果引擎最终找到了变量a，就会将2赋值给它。否则引擎会抛出一个异常

 

# 查询(执行的第一步)
　　在引擎执行的第一步操作中，对变量a进行了查询，这种查询叫做LHS(Left-hand Side)查询。实际上，引擎查询共分为两种：LHS查询和RHS查询 

　　从字面意思去理解，当变量出现在赋值操作的左侧时进行LHS查询，出现在右侧时进行RHS查询

　　更准确地讲，RHS查询与简单地查找某个变量的值没什么区别，而LHS查询则是试图找到变量的容器本身，从而可以对其赋值

function foo(a){
    console.log(a);//2
}
foo( 2 );
　　这段代码中，总共包括4个查询，分别是：

　　1、foo(...)对foo进行了RHS引用

　　2、函数传参a = 2对a进行了LHS引用

　　3、console.log(...)对console对象进行了RHS引用，并检查其是否有一个log的方法

　　4、console.log(a)对a进行了RHS引用，并把得到的值传给了console.log(...)

 

嵌套
　　在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止

function foo(a){
    console.log( a + b ) ;
}
var b = 2;
foo(2);// 4
　　在代码片段中，作用域foo()函数嵌套在全局作用域中。引擎首先在foo()函数的作用域中查找变量b，并尝试对其进行RHS引用，没有找到；接着，引擎在全局作用域中查找b，成功找到后，对其进行RHS引用，将2赋值给b

 

异常
　　为什么区分LHS和RHS是一件重要的事情？因为在变量还没有声明（在任何作用域中都无法找到变量）的情况下，这两种查询的行为不一样

RHS

【1】如果RHS查询失败，引擎会抛出ReferenceError(引用错误)异常

//对b进行RHS查询时，无法找到该变量。也就是说，这是一个“未声明”的变量
function foo(a){
    a = b;  
}
foo();//ReferenceError: b is not defined
【2】如果RHS查询找到了一个变量，但尝试对变量的值进行不合理操作，比如对一个非函数类型值进行函数调用，或者引用null或undefined中的属性，引擎会抛出另外一种类型异常：TypeError(类型错误)异常

function foo(){
    var b = 0;
    b();
}
foo();//TypeError: b is not a function
LHS

【1】当引擎执行LHS查询时，如果无法找到变量，全局作用域会创建一个具有该名称的变量，并将其返还给引擎

function foo(){
    a = 1;  
}
foo();
console.log(a);//1
【2】如果在严格模式中LHS查询失败时，并不会创建并返回一个全局变量，引擎会抛出同RHS查询失败时类似的ReferenceError异常

function foo(){
    'use strict';
    a = 1;  
}
foo();
console.log(a);//ReferenceError: a is not defined
 

原理
function foo(a){
    console.log(a);
}
foo(2);
　　以上面这个代码片段来说明作用域的内部原理，分为以下几步：

【1】引擎需要为foo(...)函数进行RHS引用，在全局作用域中查找foo。成功找到并执行

【2】引擎需要进行foo函数的传参a=2，为a进行LHS引用，在foo函数作用域中查找a。成功找到，并把2赋值给a

【3】引擎需要执行console.log(...)，为console对象进行RHS引用，在foo函数作用域中查找console对象。由于console是个内置对象，被成功找到

【4】引擎在console对象中查找log(...)方法，成功找到

【5】引擎需要执行console.log(a)，对a进行RHS引用，在foo函数作用域中查找a，成功找到并执行

【6】于是，引擎把a的值，也就是2传到console.log(...)中

【7】最终，控制台输出2


# 动态作用域
　　javascript使用的是 *** 词法作用域 *** ，它最重要的特征是它的定义过程发生在代码的书写阶段。

　　那为什么要介绍动态作用域呢？实际上动态作用域是javascript另一个重要机制this的表亲。作用域混乱多数是因为词法作用域和this机制相混淆，傻傻分不清楚

　　动态作用域并不关心函数和作用域是如何声明以及在任何处声明的，只关心它们从何处调用。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套

var a = 2;
function foo() {
    console.log( a );
}
function bar() {
    var a = 3;
    foo();
}
bar(); // 2
　　【1】如果处于词法作用域，也就是现在的javascript环境。变量a首先在foo()函数中查找，没有找到。于是顺着作用域链到全局作用域中查找，找到并赋值为2。所以控制台输出2

　　【2】如果处于动态作用域，同样地，变量a首先在foo()中查找，没有找到。这里会顺着调用栈在调用foo()函数的地方，也就是bar()函数中查找，找到并赋值为3。所以控制台输出3

　　两种作用域的区别，简而言之，词法作用域是在定义时确定的，而动态作用域是在运行时确定的



* 声明从它们在代码中出现的位置被“移动”到了最上面，这个过程就叫作提升(hoisting)

引擎会在解释javascript代码之前首先对其进行编译。编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来

   # 包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理

var a = 2 ;
　　这个代码片段实际上包括两个操作：var a 和 a = 2 
　　第一个定义声明是在编译阶段由编译器进行的。第二个赋值操作会被留在原地等待引擎在执行阶段执行————也就是a = 2时序靠后，相当于var a 时序提升了。

hoisting只是不报错，但是输出还是按照词法作用域，是undefined。
foo(); // 1
function foo(){
    console.log(1);
}
# 函数声明的提升有效，但函数表达式却不行。相当于在对undefined进行函数调。
foo(); // TypeError: foo is not a function
var foo = function(){
    console.log(1);
}
上述foo()不会导致ReferenceError。但是foo此时并没有赋值，foo()由于对undefined值进行函数调用而导致非法操作，因此会抛出TypeError异常
　　函数声明和变量声明都会被提升。但是，函数声明会覆盖变量声明

　　[注意]变量的重复声明是无用的，但函数的重复声明会覆盖前面的声明(无论是变量还是函数声明)

for (var i= 0; i<10; i++) {
    console.log(i);
}
　　上面这段是很熟悉的循环代码，通常是因为只想在for循环内部的上下文中使用变量i，但实际上i可以在全局作用域中访问，污染了整个作用域

for (var i= 0; i<10; i++) {
     console.log(i);
}
console.log(i);//10
let关键字可以将变量绑定到所在的任意作用域中(通常是{...}内部)， *** 实现块作用域. ***
　for循环头部的let不仅将i绑定到了for循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值

# 下面代码中，由于闭包只能取得包含函数中的任何变量的最后一个值（或者说i是全局变量，所以for内闭包指向唯一的全局变量i的地址，循环结束i是5），所以控制台输出5，而不是0
var a = [];
for(var i = 0; i < 5; i++){
    a[i] = function(){
        return i;
    }
}
console.log(a[0]()); // 5，因为这里i是全局i，用的是同一个作用域。

当然，可以通过函数传参，来保存每次循环的值
var a = [];
for(var i = 0; i < 5; i++){
    a[i] = (function(j){
        return function(){
            return j;
        }
    })(i);
}
console.log(a[0]()); // 0

而使用let则更方便，由于let循环有一个重新赋值的过程，相当于保存了每一次循环时的值。 *** let产生了5个块级作用域{} ***
var a = [];
for(let i = 0; i < 5; i++){
    a[i] = function(){
        return i;
    }
}
console.log(a[0]()); // 0
# var 初始变量在for循环体内，是覆盖式的，用C的话来讲是共用体，即共用同一内存地址
# for内let初始变量在每一次循环中，都是一个独立的变量，拥有自己独立的内存地址。  for外let的变量i，就是一个变量。
{
    let j;
    for (j = 0; j < 5; j++) {
        let i = j; // 每个迭代重新绑定，重新声明
        a[i] = function(){
            return i;
        }
    }
}
for循环中用let或是var来初始化变量，与是否产生闭包均无关：

函数用var还是用let来定义与是否形成闭包无关，仅仅影响外部是否能直接调用该函数。

# 但如果函数内引用的变量是let定义的局部变量，那就会形成闭包；

如果函数内引用的是for内var定义的全局变量，那就不形成闭包。



  function user (){
         let i=1;
         function show(){
             console.log(++i)
         }
         show();
     }
     user();//输出2
     user();//输出2
     每次user();使用的时候，会开辟一个新的内存空间，然后使用函数user，所以i始终都被let声明i=1；
     所以我们无论调用几次 user(); 这里输出都是2，并不会调用一直累加输出例如2,3,4,5这样；
     因为每次使用都会声明一个新的内存空间

     function user (){
        let i=1;
       return   function (){
            console.log(++i)
        }
    }
  let a=  user();
  a();//输出2
  a();//输出3
  a();//输出4
  那为什么会出现这种情况呢，其实是这样的，在user里面我们return返回了一个函数
  由于我们把user();指向了a，这里我们会开辟一个内存空间，会把 i 和 return 函数都指向了这个内存空间
  由于我们指向了a，所以内存并不会被销毁，所以我们每次调用a()的时候都会指向原来开辟的那个空间，
  所以会出现输出2,3,4这种情况

解释为什么for (var i = 0; i<=5; i++){setTimeout(()=>{console.log(i)})}输出是6个6。如下在每次执行循环体之前，var声明的i并不会在循环体上下文中重新声明和初始化一次，这个步骤在i实际所在外部就近函数或者全局函数中完成。因此，当A作用域中如果是一个函数setTimeout(()=>{console.log(i)})，产生了闭包。依照闭包中i仍保持着对外部A作用域中活动对象i的引用的逻辑，但是作用域A中并没用i。所以顺着作用域链往上找，直到找到实际i所在外部就近函数或者全局函数，找到了还需要等循环走完，返回实际i为6的值。
for (var i = 0; i <= 5; i++)
{
    // 作用域A
}
/*
    作用域如下：
    i 在外部就近函数或者全局函数中
    A: {
        // 6个副本
     }
 */
而for let { 循环体 } 在每次执行循环体之前，JS 引擎会把 i 在循环体的上下文中重新声明及初始化一次。6个副本B作用域中都会重新声明及初始化一次i，那么如果B作用域中是一个函数setTimeout(()=>{console.log(i)})，产生了闭包。那么闭包中的i自然而然仍保持着对外部B作用域中活动对象i的引用。
/*
    作用域如下：
    A: {
        B: {
            i 变量在B作用域中
            // 6个副本
        }
    }
 */

块级作用域：
try{
    throw 2;
}catch(a){
    console.log( a ); // 2
}
console.log( a ); //ReferenceError: a is not defined

# 作用域是一套规则，用于确定在何处以及如何查找标识符。

　　作用域分为词法作用域和动态作用域(执行上下文)。javascript使用词法作用域，简单地说，词法作用域就是定义在词法阶段的作用域，是由写代码时将变量和函数写在哪里来决定的。于是词法作用域也可以描述为程序源代码中定义变量和函数的区域。各个作用域的嵌套关系组成了一条作用域链。
使用作用域链主要是进行标识符的查询，标识符解析就是沿着作用域链一级一级地搜索标识符的过程，而作用域链就是要保证对变量和函数的有序访问

　　【1】如果自身作用域中声明了该变量，则无需使用作用域链
　【2】如果自身作用域中未声明该变量，则需要使用作用域链进行查找

　　这时，就引出了另一个概念——自由变量。在当前作用域中存在但未在当前作用域中声明的变量叫自由变量
在下面的例子中，如果要在bar函数中查询变量b，由于b并没有在当前作用域中声明，所以b是自由变量。bar函数的作用域链是bar -> fn -> 全局。到上一级fn作用域中查找b没有找到，继续到再上一级全局作用域中查找b，找到了b：
var a = 1;
var b = 2;

function fn(x){
    var a = 10;

    function bar(x){
        var a = 100;
        b = x + a;
        return b;
    }
    bar(20);
    bar(200);
}
fn(0);
# 如果标识符没有找到，则需要分为RHS和LHS查询进行分析，若进行的是LHS查询，则在全局环境中声明该变量，若是严格模式下的LHS查询，则抛出ReferenceError(引用错误)异常；若进行的是RHS查询，则抛出ReferenceError(引用错误)异常。
执行环境(execution context)，有时也称为执行上下文、执行上下文环境或环境，定义了变量或函数有权访问的其他数据。每个执行环境都有一个与之关联的变量对象(variable object *** this ***)，环境中定义的所有变量和函数都保存在这个对象中

　　一定要区分执行环境和变量对象。执行环境会随着函数的调用和返回，不断的重建和销毁。但变量对象在有变量引用(如闭包)的情况下，将留在内存中不被销毁。
这是上面代码执行到第15行时fn(0)函数的执行环境，执行环境里的变量对象保存了fn()函数作用域内所有的变量和函数的值：
x:0
a:undefined
bar:function
arguments:[0]
this:window
执行流是第1行 -> 第2行 -> 第4行 -> 第15行 -> 第5行 -> 第7行 -> 第12行 -> 第8行 -> 第9行 -> 第10行 -> 第11行 -> 第13行 -> 第8行 -> 第9行 -> 第10行 -> 第11行 -> 第14行
执行环境栈类似于作用域链，有序地保存着当前程序中存在的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。javascript程序中的执行流正是由这个机制控制着。

总结
　　【1】javascript使用的是词法作用域。对于函数来说，词法作用域是在函数定义时就已经确定了，与函数是否被调用无关。通过作用域，可以知道作用域范围内的变量和函数有哪些，却不知道变量的值是什么。所以作用域是静态的

　　[注意]通过eval()函数和with语句可以对作用域进行动态修改

　　【2】对于函数来说，执行环境是在函数调用时确定的，执行环境包含作用域内所有变量和函数的值。在同一作用域下，不同的调用(如传递不同的参数)会产生不同的执行环境，从而产生不同的变量的值。所以执行环境是动态的

https://www.jb51.net/article/161608.htm
https://xiaohuochai.site/JS/ECMA/this/binding.html

# this 对象就是指向函数当前的执行环境，执行环境是会在 Event Loop（事件循环）过程中变化的，因此 this 在函数环境下是属于运行时的。
var name = 'Tom';
 
var obj = {
  name: 'Iceberg',
  say: function() {
    console.log('my name is ' + this.name);
  },
  sub: {
    say: function() {
      console.log('my name is ' + this.name);
    }
  }
};
 
obj.say(); // my name is Iceberg
obj.sub.say() // my name is undefined;
 
var say = obj.say;
say(); // my name is Tom;
上面的例子说明 obj.say() 执行环境为 obj 对象，而 obj.sub.say() 的执行环境却是 obj.sub 对象，而对于 obj.sub 来说并没有 name 属性，因此为 undefined；
# 而 var say = obj.say; 则表示将 say 方法的内存地址赋值给全局变量，因此从全局变量 name 中取值。

var handler = {
	nickname: 'anonymous',
	register: function() {
	  console.log(this.nickname);
	}	
}
$('#registerBtn').on('click', handler.register); // undefined

以上逻辑点击触发后输出的是 undefined，因为函数被当做事件触发的回调函数执行时，相当于把handler.register函数赋值给对应的click事件，this也指向该触发事件对应的元素，如要 this 仍然以 handler 对象为执行环境，则可使用函数的 bind 方法进行执行环境对象的绑定操作。
$('#registerBtn').on('click', handler.register.bind(handler)); // anonymous

在 react 中经常需要在回调函数中调用 this.state、this.props，按照上面的分析，将当前环境对象 bind 到回调函数中即可。

# 如果是使用的箭头函数定义回调函数即可无需 bind，因为箭头函数中 this 就是对应定义时所在的对象。