go env
go version
go tool compile -S filename.go  // 汇编

#以下两种命令都可以
go tool compile -S main.go
go build -gcflags -S main.go


如果定义了一个没有任何方法的空接口，那么这个接口可以表示任意类型;   m := make(map[string]interface{})

在Go语言中，make是一个内建函数，用于创建切片（slice）、映射（map）或通道（channel）等引用类型。它用于分配并初始化一个新的、类型化的内存块，并返回该类型的引用。
slice2 := make([]float32, 3, 5) // [0 0 0] 长度为3容量为5的切片

b := make([]float32, 3, 5)
b = append(b, 1, 2, 3, 4)

c := make([]float64, 3, 5)
c = append(c, 1, 2, 3, 4)
为什么b扩容之后容量是12，c扩容之后容量是10 ?
当前长度3，容量5，加四个元素，期望长度为7，超过当前容量发生扩容，根据golang扩容策略当前容量翻倍为10（或者更大，具体取决于实现）。
为提高内存利用率，扩容后的切片还要进行内存对齐，根据你最后的结果可以推测你的电脑是64位系统，10容量下的float32需要40字节，内存要向上对齐到48字节，最后真实扩容容量为48/4=12

在许多计算机系统中，为了提高内存访问速度和效率，内存地址需要对齐到特定的字节边界。对于float32类型的数据，通常需要将其对齐到4字节的边界。因此，如果一个float32数据在内存中的起始地址不是4的倍数，那么就需要进行内存填充（padding）来使其对齐到4字节的边界。

由于每个float32数据需要占用4字节的内存空间，因此这10个数据的总字节数是40字节。但是，如果这10个数据的起始地址不是4的倍数，那么就需要进行内存填充来使其对齐到4字节的边界。

假设这10个float32数据的起始地址是32字节的倍数（例如，32、64、96等），那么就不需要进行内存填充。但是，如果起始地址不是32字节的倍数（例如，40、48、56等），那么就需要进行内存填充。在这种情况下，填充的字节数会使得数据的起始地址变为32字节的倍数。

因此，如果你的10个float32数据的起始地址不是32字节的倍数，那么在每个数据之间就会填充一定数量的字节，使得它们的起始地址对齐到32字节的边界。这样做的目的是为了提高内存访问速度和效率。