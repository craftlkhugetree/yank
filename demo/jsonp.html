<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
</head>

<body>
    <img src="abc.jpg" onerror="imgerrorfun(this);" />

    <script>
        window.addEventListener('unhandledrejection', function (e) {
            console.log('unhandledrejection:', e);
        });
        window.onerror = function (message, source, lineno, colno, error) {
            console.log('捕获到异常：', { message, source, lineno, colno, error });
        };
        window.addEventListener('error', error => {
            console.log('listen error:', error);
        });
        window.frames && window.frames.length ? window.frames[0].onerror = function (message, source, lineno, colno, error) {
            console.log('捕获到 iframe 异常：', { message, source, lineno, colno, error });
            return true;
        } : void 0;

        /*img图片404错误方法*/
        function imgerrorfun(img) {
            img.src = "./工程化.jpg";/*默认图片相对路径*/
            img.οnerrοr = null; /*控制不要一直跳动*/
        }

        function myJsonp(options) {
            return new Promise((resolve, reject) => {
                //判断是否是第一次jsonp请求
                if (!window.jsonpNum) {
                    window.jsonpNum = 1;
                } else {
                    window.jsonpNum++;
                }

                let {
                    url,
                    data,
                    timeout = 5000,
                    // 这里callback这个键名是前后端约定好的
                    cbkey = 'callback',
                } = options;

                //保证每次请求接收的方法都不会重复
                let funName = 'jsonpReceive' + window.jsonpNum;

                //清除本次jsonp请求产生的一些无用东西
                function clear() {
                    window[funName] = null;
                    script.parentNode.removeChild(script);
                    clearTimeout(timer);
                }

                //定义jsonp接收函数
                window[funName] = function (res) {
                    //一旦函数执行了，就等于说请求成功了
                    resolve(res);
                    clear();
                };

                //请求超时计时器
                let timer = setTimeout(() => {
                    reject('超时了');
                    clear();
                }, timeout);

                //定义请求的参数
                let params = '';

                //如果有参数
                if (Object.keys(data).length) {
                    for (let key in data) {
                        params += `&${key}=${encodeURIComponent(data[key])}`;
                    }

                    params = params.substr(1);
                }

                //拼接最终的请求路径，结尾拼接回调的方法名
                url = url + '?' + params + `&${cbkey}=${funName}`;

                let script = document.createElement('script');
                script.src = url;
                document.body.appendChild(script);
            });
        }
        let options = {
            url: 'https://c.y.qq.com/musichall/fcgi-bin/fcg_yqqhomepagerecommend.fcg',
            cbkey: 'jsonpCallback',
            data: {
                g_tk: 1928093487,
                inCharset: 'utf-8',
                outCharset: 'utf-8',
                notice: 0,
                format: 'jsonp',
                platform: 'h5',
                uin: 0,
                needNewCode: 1,
            },
            // QQ音乐接口Jsonp字段
        };

        myJsonp(options).then(
            res => {
                console.log(res);
            },
            err => {
                console.log(err);
            }
        );

      // 后端返回该函数的调用，将数据作为参数传递进去，再将整个函数的调用返回给客户端
      // myCallback({
      //         name: 'ahreal',
      //         age: 18
      //     })
    </script>
</body>

</html>