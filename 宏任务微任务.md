所谓宏任务，我们可以理解成，<script> 标签中主代码执行，一次用户交互（比如触发了一次点击事件引起的回调函数），定时器 setInterval ，延时器 setTimeout 队列， MessageChannel 等。这些宏任务通过 event loop，来实现有条不紊的执行。

例如在浏览器环境下，宏任务的执行并不会影响到浏览器的渲染和响应。

什么是微任务呢 ？

那么我们再来分析一下微任务，在 js 执行过程中，我们希望一些任务，不阻塞代码执行，又能让该任务在此轮 event loop 执行完毕，那么就引入了一个微任务队列的概念。

微任务相比宏任务有如下特点：

微任务在当前 js 执行完毕后，立即执行，会阻塞浏览器的渲染和响应。
一次宏任务完毕后，会清空微任务队列。
常见的微任务，有 Promise， queueMicrotask ，浏览器环境下的 MutationObserver ，node 环境下 process.nextTick 等。

讲完了宏任务和微任务，继续来看第一种批量更新的实现，就是基于宏任务 和 微任务 来实现。

先来描述一下这种方式，比如每次更新，我们先并不去立即执行更新任务，而是先把每一个更新任务放入一个待更新队列 updateQueue 里面，然后 js 执行完毕，用一个微任务统一去批量更新队列里面的任务，如果微任务存在兼容性，那么降级成一个宏任务。这里优先采用微任务的原因就是微任务的执行时机要早于下一次宏任务的执行。

典型的案例就是 vue 更新原理，vue.$nextTick 原理 ，还有 v18 中 scheduleMicrotask 的更新原理。

以 vue 为例子我们看一下 nextTick 的实现：runtime-core/src/scheduler.ts

```javascript
const p = Promise.resolve();
/* nextTick 实现，用微任务实现的 */
export function nextTick(fn?: () => void): Promise<void> {
  return fn ? p.then(fn) : p;
}
```

可以看到 nextTick 原理，本质就是 Promise.resolve() 创建的微任务。

再看看 react v18 里面的实现。react-reconciler/src/ReactFiberWorkLoop/ensureRootIsScheduled

```javascript
function ensureRootIsScheduled(root, currentTime) {
  /* 省去没有必要的逻辑 */
  if (newCallbackPriority === SyncLane) {
    /* 支持微任务 */
    if (supportsMicrotasks) {
      /* 通过微任务处理 */
      scheduleMicrotask(flushSyncCallbacks);
    }
  }
}
```

接下里看一下 scheduleMicrotask 是如何实现的。

```javascript
/* 向下兼容 */
var scheduleMicrotask =
  typeof queueMicrotask === 'function'
    ? queueMicrotask
    : typeof Promise !== 'undefined'
    ? function (callback) {
        return Promise.resolve(null).then(callback).catch(handleErrorInNextTick);
      }
    : scheduleTimeout;
```
scheduleMicrotask 也是用的 Promise.resolve ，还有一个 setTimeout 向下兼容的情况。
