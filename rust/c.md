#： 字符串化，使用时需加"" ##：组合 2 个 C 语言标识符（token）

```c
#include <stdio.h>

#define TOKEN_PASTER(n)  printf("num_"#n"= %d\n",num_##n)

int main(void)
{
    int num_1 = 100;

    TOKEN_PASTER(1); // num_1= 100

    return 0;
}
```

```c
#include<stdio.h>

void main(void)
{
    char buf[4];
    const char a = 0;

    buf[-1] = 88;
    printf("the a is %d\n" ,a); // the a is 88
}
```

说明：const 修饰的变量，其实质是告诉程序员和编译器该变量为只读，而对于像数组溢出，隐式修改等程序不规范书写造成的运行过程中的修改，编译器是无能为力的，也说明 const 修饰的变量仍然是具备变量属性的。

```c
#include<stdio.h>

typedef struct {
    int a;
    int b;
    int c;
} TEST;

TEST arr[]={
    {1,2,3},
    {4,5,6},
    {7,8,9}
};

void main(void)
{
    TEST *tmp;
    tmp = arr;

    printf("tmp: %d, %d, %d,%d, %d, %d,%d, %d, %d\n", tmp[0].a, tmp[0].b, tmp[0].c, tmp[1].a, tmp[1].b, tmp[1].c, tmp[2].a, tmp[2].b, tmp[2].c);
    printf("arr: %d, %d, %d,%d, %d, %d,%d, %d, %d\n", arr[0].a, arr[0].b, arr[0].c, arr[1].a, arr[1].b, arr[1].c, arr[2].a, arr[2].b, arr[2].c);
}
// tmp: 1, 2, 3,4, 5, 6,7, 8, 9
// arr: 1, 2, 3,4, 5, 6,7, 8, 9
```

结果分析：
1）数组名可以直接赋值给相同类型的指针变量
2）指针变量可以采用类似数组的用法，如：tmp[0].a

注：不能将数组名赋值给数组变量，如：
TEST jj[3];
jj = arr;
编译将产生错误： error: incompatible types when assigning to type ‘struct TEST[3]’ from type ‘struct TEST \*’
————————————————
原文链接：https://blog.csdn.net/u012247418/article/details/98349995

```c
#include <stdio.h>

void main()
{

    char a[2][3];
    char *b;
    char c[5];

    b=c;

    printf("addr of arr:\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n"
            ,a,a+1,&a,&a+1,a[0],a[0]+1,&a[0],&a[0]+1,&a[0][0],&a[0][0]+1);
    printf("addr of ptr:\n%p\n%p\n%p\n%p\n%p\n",c,&c,&c[0],b,&b);
    printf("sizeof:%d\t%d\t%d\t%d", sizeof(c), sizeof(&c), sizeof(b), sizeof(&b));
    printf("addr of arr+1:\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n",c,c+1,&c,&c+1,b,b+1,&b,&b+1);
}
// addr of arr:
// 0x7ffeaecec0ca
// 0x7ffeaecec0cd
// 0x7ffeaecec0ca
// 0x7ffeaecec0d0
// 0x7ffeaecec0ca
// 0x7ffeaecec0cb
// 0x7ffeaecec0ca
// 0x7ffeaecec0cd
// 0x7ffeaecec0ca
// 0x7ffeaecec0cb
// addr of ptr:
// 0x7ffeaecec0bb
// 0x7ffeaecec0bb
// 0x7ffeaecec0bb
// 0x7ffeaecec0bb
// 0x7ffeaecec0c0
// sizeof:5	8	8	8
// addr of arr+1:
// 0x7ffeaecec0bb
// 0x7ffeaecec0bc
// 0x7ffeaecec0bb
// 0x7ffeaecec0c0
// 0x7ffeaecec0bb
// 0x7ffeaecec0bc
// 0x7ffeaecec0c0
// 0x7ffeaecec0c8
```

分析：
1）a、&a、a[0]、&a[0]、&a[0][0]都代表 2 维数组 a[2][3]的首地址，但是地址加 1 的步长有区别。
a+1; 第二行第一个元素的地址
&a+1; 二维数组之后的首个地址
a[0]+1; 二维数组第一行第二个元素地址
&a[0]+1; 二维数组第二行第一个元素地址
&a[0][0]+1; 二维数组第一行第二个元素地址

2）b 是指针变量，&b 是指存放指针的地址！！b 是指向数组 c 的首地址，两者不同。
&c[0] 表示 c 数组的第一个元素的地址。
&c+1 表示整个数组之后的地址，c+1 表示首元素之后的第二个元素的地址。所以 sizeof(&c)是 8 字节指针，sizeof(c)是 5 字节数组大小。
&arr 代表的是整个一维数组的地址，arr 代表的是数组第一个元素的地址，它们在计算时会有很大的差异，比如+1 的结果就不一样。
arr 本身是左值，&arr 是右值表达式，为指针类型，指向 arr 本身。
简单来说就是 arr 本身不是地址而是指代整个数组，只不过会隐式转成指针罢了。
arr （转换后）和 &arr 类型不同，数值相等是因为 arr 和 arr[0] 地址相同，这里地址指首地址。

# A[B]是*(A+B)的语法糖，或者简单理解为缩写。因为*(a+3)和\*(3+a)效果是一样的，所以 a[3]还是 3[a]都行。丧心病狂的话还能写 ((5>4)<<2)[-1+a]

7=7（不合法，是赋值运算不是关系运算）
5>4>3（合法 5>4--->1; 1>3--->0,所以该运算结果为 0）
1<2<3（合法 1<2---->1; 1<3--->1,所以该运算结果为 1）
1<<2 为 4； 4[-1+a]为 a[3]

```c

```

# 指针的大小是固定的 4/8 个字节（32 位平台/64 位平台）

我们都知道 cpu 是无法直接在硬盘上读取数据的，而是通过内存读取。cpu 通过地址总线、数据总线、控制总线三条线对内存中的数据进行传输和操作。

具体流程：

1、cpu 通过地址总线，找到该条数据；

2、通过控制总线得知该操作是读操作还是写操作；

3、通过数据总线将该数据读取到 cpu 或者从 cpu 写到内存中。

所以，

地址总线的宽度决定了 CPU 的寻址能力；
　　数据总线的宽度决定了 CPU 单次数据传输的传送量，也就是数据传输速度；
　　控制总线决定了 CPU 对其他控件的控制能力以及控制方式

我们平时所说的计算机是 64 位、32 位、16 位，指的是计算机 CPU 中通用寄存器一次性处理、传输、暂时存储的信息的最大长度。即 CPU 在单位时间内(同一时间)能一次处理的二进制数的位数。
假如，某计算机的地址总线是 64 位，那么其一次可以在 2^64 种可能中寻找一个地址，也就是其描述的地址空间为 0x0000 0000 0000 0000 0000 0000 0000 0000 ~ 2^64-1。
我们一般需要 64 个 0 或 1 的组合就可以找到内存中所有的地址，而 64 个 0 或 1 的组合，就是 64 个位，也就是 8 个字节的大小，因此，我们只需要 8 个字节就可以找到所有的数据。所以，在 64 位的计算机中，指针占 8 个字节。同理，在 32 位的计算机中，指针占 4 个字节。

同时也可以看出，由于地址总线为 64，那么每次寻址的空间为 0x0000 0000 0000 0000 0000 0000 0000 0000 ~ 2^64-1，那么 CPU 数据传输中能找到的的最大地址为 2^64 位，即最大内存为 2^64Byte=16eb

其他知识点：

数据存储是以“字节”（Byte）为单位，数据传输大多是以“位”（bit，又名“比特”）为单位，一个位就代表一个 0 或 1（即二进制），每 8 个位（bit，简写为 b）组成一个字节（Byte，简写为 B），是最小一级的信息单位。
1bit 就是二进制的 0 和 1
1 字节(Byte) = 8 位(bit)=8 比特
1 个英文字母（不分大小写）占一个字节的空间
计算机能够处理的最小单元是 字节 而不是位

————————————————
原文链接：https://blog.csdn.net/qq_38325803/article/details/103093623

```c
#include<stdio.h>
int main()
{
	int arr[5] = { 1,2,3,4,5 };
    // 两个指针指向同一块空间时，指针减指针的绝对值得到的就是这两个指针之间数据的个数。
	printf("%d", &arr[4] - &arr[0]);  // 4
	return 0;
}
```

野指针的概念就是：指针的位置是不可知的。
野指针的成因有两个：1.指针未被初始化 2.指针的越界访问。
如何避免野指针？

1. 善于使用 NULL，及时对指针进行初始化
   如果你在定义指针变量的时候，就已经想到指针变量指向的对象，那就直接进行初始化。
   如果你在定义的时候，还不清楚指针指向的对象，也不清楚后面要不要使用指针，那就对指针变量赋值为 NULL。
   NULL 就是空的意思，如果 int \*p=NULL; 那么此时 p 就是一个空指针，后面可以重新赋值，并不影响后面的使用。如果一个指针是空指针，在你还没初始化前不要使用它。

2. 避免指针的越界

3. 避免返回局部变量的地址

通常情况下数组名是首元素的地址，但凡事都有例外：

1. sizeof(数组名) 得到的是整个数组的大小
2. &+数组名 这里取出的是整个数组的地址。
3. 在进行函数传参时，如果形参是数组，可以把形参设计成指针，当然如果形参是数组，也可以传指针作为实参。

```c
#include<stdio.h>
int main()
{
	int arr1[3] = { 1,2,3 };
	int arr2[3] = { 4,5,6, };
	int* arr3[2] = {arr1,arr2};
	int i = 0;
	int j = 0;
	for (i = 0; i < 2; i++)
	{
		for (j = 0; j < 3; j++)
		{
            // arr3[i][j]
			printf("%d ", *(arr3[i] + j));
		}
		printf("\n");
	}
}
// 1 2 3
// 4 5 6
```

指针数组:
int* p1[10];
p1是指针数组。
下标引用[ ]的优先级高于间接访问*，p1先与[ ]结合为p1[10]，是一个有10个元素的数组。其次再与 int *结合，即每个元素的类型是int *

数组指针:
int (*p2)[10];
p2是数组指针。
虽然[ ]优先级高于*，但因为存在( )。p2先与 *结合，说明p2是一个指针变量。p2指向一个数组，该数组有10个int类型的变量。
p2的类型是：int (*)[10]。 去掉变量名，即为数组指针的类型。

# p2+1会跳过一个包含10个int类型元素的数组。

    char (*p)[5] = NULL;
    char (*p1)[5] = NULL;
    char a[5] = {0,1,2,3,4};
    p = a;
    p1 = &a;
由于p是一个指向数组的指针，*p = p, p+1=*(p+1)，why？
类似于两级指针（把数组也当成一级指针，尽管数组不是指针），p代表一个数组的地址，*(p+0)代表一个数组首元素的地址，所以p=*p，但是他们表示的范围不同，**p即代表a[0]；p+1与*(p+1)同理。
————————————————
原文链接：https://blog.csdn.net/u012247418/article/details/100622052

```c
int arr[]={1,2,3,4,5,6,7,8,9,10};
int (*p)[10]=&arr;
int sz=sizeof(arr)/sizeof(arr[0]);
int i=0;
for(i=0;i<sz;i++)
{
	printf("%d ",*(*p+i));
}
```
p是数组指针，存放着数组arr的地址，指向数组arr。
*p标识了一个包含10个整型元素的数组arr。*p相当于数组名arr。我们知道数组名是数组首元素的地址，故 *p是数组arr首元素的地址，也是个指针。

p是数组arr的地址，所以p+1跳过了整个数组的字节大小。
根据图中打印出来的地址，我们可以看到：
数组地址+1减去数组地址，即16进制的90-68=28，转换成10进制就是40，刚好是一个有着10个int类型元素的数组的大小。

*p相当于数组名arr，是数组首元素的地址。所以 *p+1跳过了一个int类型。
根据图中打印出来的地址，我们可以看到：
数组首元素地址+1减去数组首元素地址，即16进制的6C-68=4。这是一个int类型值的大小。

# p是数组指针，存放着数组arr的地址，指向数组arr。
# *p相当于(p所指的数组的)数组名arr， 所以 *p也是数组arr首元素的地址。
————————————————
原文链接：https://blog.csdn.net/2301_77446344/article/details/132852351


# 大端模式（Big_endian）：字数据的高字节存储在低地址中，而字数据的低字节则存放在高地址中。符合常理。   12345678
# 小端模式（Little_endian）：字数据的高字节存储在高地址中，而字数据的低字节则存放在低地址中。          78563412

联合体变量的各个成员都是从低字节开始公用的（这是最重要的）

union内存特点主要有如下：

联合体的所有成员相对于基地址的偏移量为0
联合的内存大小等于其中最大成员的大小。
联合的所有成员共享同一块内存区域，即它们的存储位置是相同的。
其对其方式要适合于联合体中所有类型的成员

代码中使用了一个联合体来测试CPU字节序。联合体中包含了一个int类型的成员和一个char类型的成员。因为int类型占据了4个字节，而char类型只占据了一个字节，所以当联合体中的整型变量被设置为1时，如果该CPU是小端序，它在内存中的存储顺序将会是0x01 00 00 00，而char类型变量所占据的第一个字节的值应该为1。如果是大端序，它在内存中的存储顺序将会是0x00 00 00 01，而char类型变量b所占据的第一个字节的值应该为0。
```c
#include<stdio.h>
 
int is_little_endian()
{
    union check
    {
        int i;
        char a;
    }u;
 
    u.a=0;
    u.i=1;
 
    return(u.a == 1);
}
 
union test
{
    int i;
    char a[2];
}*p,test;
 
 
void main()
{
    if(is_little_endian())
        printf("the system is liite endian.\n");
    else
        printf("the system is big endian.\n");
 
    p = &test;
    p->a[0] = 0x12;
    p->a[1] = 0x34;
 
    printf("p->i = %x\n", p->i); 
    // the system is liite endian.
    // p->i = 3412
}
```

```c
#include <stdio.h>
 int fun1(int **p)    // = int *p[5];  *p 是存放int变量的地址， **p是存放该地址的变量的地址； int *p[5]是存放int型变量的地址的 指针数组
{
    return 0;
}
  
int fun2(int a[][5])    // = int (*a)[5]   前者为二维数组，而int (*a)[5]是数组指针，指向二维数组某一行
{
    return 0;
}

int main()
{ 
    int **p;
    int (*p2)[5];
    int *array[5];
    int array2[3][5];
 
    p = array;
    p = &(array[1]);
    p2 = &(array2[1]);
    p2 = array2;
 
    fun1(p);
    fun1(array);
    fun1(&(array[0]));
 
 
    fun2(p2);
    fun2(array2);
    fun2(&(array2[0]));
}
```

1、判断一个数是否是无符号数

#define ISUNSIGNED(a)  (a>=0  &&  ~a>=0)

解析：（1）如果一个数小于0，则它是有符号数；

    （2）如果一个数大于0，则对它按位取反（包括符号位），若仍大于0，则为无符号数，否则为有符号数。

2、判断一个类型是否是无符号类型

#define ISUNSIGNED(type)  ((type)0 - 1 >0)

解析：1、根据C语言的类型自动提升原则，如果type是有符号的，则与1计算的结果是有符号的，计算过程不发生类型提升，结果小于0；
    2、如果type是无符号的，则发生类型提升，1先转换为无符号类型，计算结果同样为无符号类型，结果大于0。
    3、2个无符号整数相减得到的也是无符号数，必然比零大，只不过会很大。
————————————————
原文链接：https://blog.csdn.net/jakiechen68/article/details/8822219


#define IS_UNSIGNED(a) ((a |= (0x1 << (sizeof(a)*8 - 1))) > 0 ? 1 : 0)
把变量的最高位置1，然后判断变量是否大于0。如果大于0，就是无符号数；否则就是有符号数。
将1左移31位到最高位后减一，再与a或。

```c
```
（1）有符号类型和无符号类型一起做运算，有符号类型会自动转成无符号类型；

（2）有符号数最高位是符号位，当有符号数是负数时，转成无符号数，则变成正数，而且一般是很大的正数；

（3）无符号数没有符号位，因此无符号数全部都大于等于0（>=0）；

（4）如果一个数是正数，它的有符号和无符号的表示都是一样，只是编译器按照不同的类型解释它。
————————————————
原文链接：https://blog.csdn.net/DayDreamingBoy/article/details/11830259


可以实现数组“自动”深拷贝的编程技巧–将数组用结构体包装起来。当然了，在我们需要数组的容量特别大的时候，还是不要使用这种方法，因为这样子预先给定大小的数组是在栈上开辟的空间，而栈的空间相对有限（在linux系统下使用ulimit选项查看进程栈空间大约为8M），不适合用于数据量特别大的情况。
————————————————
原文链接：https://blog.csdn.net/junkeal/article/details/86764461